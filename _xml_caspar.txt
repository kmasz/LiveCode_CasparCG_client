on mouseUp   # When the button is clicked, load up the preferences and put them into the field    loadPreferencesend mouseUpcommand loadPreferences    # There are two parts to loading the preferences file. The first part is reading the file into memory and    # creating an XML "tree". The second part is to process the tree and extract the data from it.        # This function reads the XML file, and returns the tree. The tree is represented as a number, the actual    # tree structure and data is managed by Revolution and so we don't need to worry about it.    local tTree    put readPreferencesToXMLTree() into tTree    if tTree is empty then        exit loadPreferences    end if# This command reads the preferences we require from the tree and displays them.    processPreferencesTree tTree        # Close the XML tree. This will free up the memory that the tree was using and prevent our     # application using more memory than it needs or "leaking" memory by creating multiple trees    # without closing any of them.    revDeleteXMLTree tTreeend loadPreferences# This function reads the XML file from disk, and turns it into an XML Tree. The tree is then returned# for the second part of the process.private function readPreferencesToXMLTree    # Find the XML file on disk. This is for now assumed to be in the same location as the stack / application.    # Note that we restore the itemDelimiter to comma (its default value) afterwards. This is not essential    # but its good practice to avoid tricky bugs that can arise due to unexpected delimiter values.    set the itemDelimiter to slash    local tPreferencesFile    put item 1 to -2 of the effective filename of this stack & "/Preferences.xml" into tPreferencesFile    set the itemDelimiter to comma        # Read the preferences data from the file into a variable. Always check for the result when reading files    # as its possible that the file may have been deleted or moved.    local tPreferencesData, tResult    put url ("file:" & tPreferencesFile) into tPreferencesData    put the result into tResult    if tResult is not empty then        answer error "Failed to read preferences file at location: " & tPreferencesFile        return empty    end if        # Create the XML "tree" from the data, checking to make sure that the file has loaded properly.    # The revCreateXMLTree function will return a number (the tree's "handle" or "id") if it succeeds,    # otherwise it will return a message saying why it failed.    local tTree    put revCreateXMLTree(tPreferencesData, false, true, false) into tTree    if tTree is not an integer then        answer error "Failed to process preferences file with error: " & tTree        return empty    end if        return tTreeend readPreferencesToXMLTreeprivate command processPreferencesTree pTree    # Extract the text color and text size preferences. These are simple nodes in the XML file,    # we can get what is inside them using the revXMLNodeContents function    # This function will return a string beginning with "xmlerr," if it fails, but we don't check this    # here as we created the file and we know it won't fail.    local tTextColor    put revXMLNodeContents(pTree, "channels/channel/video-mode") into tTextColor        local tTextSize    put revXMLNodeContents(pTree, "channels/channel/output/consumers/consumer/type") into tTextSize        # Extract the introductory message preference. This node has an attribute. We extract the contents and the     # attribute in two separate calls. The function revXMLAttribute allows us to read attributes from XML files,    # its exactly the same as revXMLNodeContents, except that you also need to tell it which attribute you want.    local tIntroMessage    put revXMLNodeContents(pTree, "preferences/introMessage") into tIntroMessage        local tIntroMessageSize    put revXMLAttribute(pTree, "preferences/introMessage", "size") into tIntroMessageSize        # Extract the recent documents list. This is a nested list of nodes, which could have any number of items.    # First, we get a list of the recent documents, then we can loop through them and get each one in turn.    # The revXMLChildNames function is useful for returning a list of nodes like this. The last parameter is important    # as it tells the function to return a unique specifier for each node, allowing us to access them correctly. This will    # look something like:    #    recentDocument[1]    #    recentDocument[2]    #    recentDocument[3]    local tRecentDocuments    put revXMLChildNames(pTree, "channels/channel/output/consumers/consumer/", return, empty,false) into tRecentDocuments        # To get each document, we just use revXMLNodeContents again. However here we concatentate the name of each node    # with the path that all recent document nodes have in common, to get the complete path.    local tListOfRecentDocuments    repeat for each line tRecentDocument in tRecentDocuments        put tRecentDocument && "=" && revXMLNodeContents(pTree, "channels/channel/output/consumers/consumer/" & tRecentDocument) & return after tListOfRecentDocuments    end repeat    delete the last char of tListOfRecentDocuments        # Now we output what we read from the file to see if it worked.    local tOutput    put "Text Color = " & tTextColor & return after tOutput    put "Text Size = " & tTextSize & return after tOutput    put return after tOutput    put "Introductory Message (size: " & tIntroMessageSize & ") = " & return after tOutput    put tIntroMessage & return & return after tOutput    put "Recent Documents = " & return after tOutput    put tListOfRecentDocuments after tOutput//put tRecentDocuments after tOutput    set the text of field "Information" to tOutput//put revXMLTree(pTree,"channels/",return,tab,false,-1) after field "Information"//put revXMLText(pTree,"channels/", false) after field "Information"end processPreferencesTree